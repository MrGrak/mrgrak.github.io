using System;
using System.Text;
using System.Diagnostics;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using System.Collections.Generic;

namespace BaseProject
{


    //small named scopes
    public struct Struct_Sm
    {
        public Boolean myBool;
    }

    public class Class_Sm
    {
        public Boolean myBool;
    }



    //medium named scopes
    public struct Struct_Med
    {
        public Boolean myBool;
        public byte myByte;
        public short myShort;
        public int myInt;
        public double myDouble;
    }

    public class Class_Med
    {
        public Boolean myBool;
        public byte myByte;
        public short myShort;
        public int myInt;
        public double myDouble;
    }


    //large named scopes
    public struct Struct_Lrg
    {
        public Boolean myBool;
        public double myDouble1;
        public double myDouble2;
        public double myDouble3;
        public double myDouble4;
        public double myDouble5;
        public double myDouble6;
        public double myDouble7;
        public double myDouble8;
        public double myDouble9;
    }

    public class Class_Lrg
    {
        public Boolean myBool;
        public double myDouble1;
        public double myDouble2;
        public double myDouble3;
        public double myDouble4;
        public double myDouble5;
        public double myDouble6;
        public double myDouble7;
        public double myDouble8;
        public double myDouble9;
    }









    public class Game1 : Game
    {
        GraphicsDeviceManager graphics;
        SpriteBatch spriteBatch;

        public Stopwatch stopWatch = new Stopwatch();
        public Stopwatch total = new Stopwatch();
        public TimeSpan timespan;
        public long averageTicks;
        public long totalTicks;
        public long frameCount;

        Vector2 position = new Vector2(4, 1);
        float rotation = 0.0f;
        Vector2 origin = new Vector2(0, 0);
        float scale = 1.0f;
        SpriteEffects spriteEffect = SpriteEffects.None;
        float zDepth = 0.1f;
        SpriteFont BitmapFont;
        Color color = Color.White;

        StringBuilder e = new StringBuilder();
        String text;
        int i;

        int j;
        List<Boolean> booleans;

        List<Struct_Sm> sm_structs;
        List<Struct_Med> med_structs;
        List<Struct_Lrg> big_structs;

        List<Class_Sm> sm_class;
        List<Class_Med> med_class;
        List<Class_Lrg> big_class;



        public Game1()
        {
            graphics = new GraphicsDeviceManager(this);
            Content.RootDirectory = "Content";
            this.IsMouseVisible = true;
            graphics.PreferredBackBufferWidth = 640;
            graphics.PreferredBackBufferHeight = 360;
        }

        protected override void Initialize()
        {
            base.Initialize();
        }

        protected override void LoadContent()
        {
            spriteBatch = new SpriteBatch(GraphicsDevice);
            BitmapFont = Content.Load<SpriteFont>("Font_Pixel");
            total.Reset(); total.Start();
            averageTicks = 0;
            totalTicks = 0;
            frameCount = 0;


            //allocated in contiguous chunk of mem? i hope so.

            booleans = new List<bool>();
            for (i = 0; i < 1000; i++) { booleans.Add(true); }
            
            sm_structs = new List<Struct_Sm>();
            for (i = 0; i < 1000; i++) { sm_structs.Add(new Struct_Sm()); }

            sm_class = new List<Class_Sm>();
            for (i = 0; i < 1000; i++) { sm_class.Add(new Class_Sm()); }

            med_structs = new List<Struct_Med>();
            for (i = 0; i < 1000; i++) { med_structs.Add(new Struct_Med()); }

            med_class = new List<Class_Med>();
            for (i = 0; i < 1000; i++) { med_class.Add(new Class_Med()); }

            big_structs = new List<Struct_Lrg>();
            for (i = 0; i < 1000; i++) { big_structs.Add(new Struct_Lrg()); }

            big_class = new List<Class_Lrg>();
            for (i = 0; i < 1000; i++) { big_class.Add(new Class_Lrg()); }
            
        }

        protected override void UnloadContent()
        {
        }

        protected override void Update(GameTime gameTime)
        {
            stopWatch.Reset();
            stopWatch.Start();
            base.Update(gameTime);
            //baseline (no forloop) = 5 ticks
            for (i = 0; i < 1000; i++) //
            {   //over 10,000 frame minimum
                //count = 1k //29 tack baseline

                //check 1000 booleans as a list, struct, or class
                for (j = 0; j < 1000; j++) //19,970
                {
                    //if (booleans[j]) { } //56,000 boolean list
                    //if (sm_structs[j].myBool) { } //59,000 sm structs list
                    //if (sm_class[j].myBool) { } //60,100 sm class list

                    //if (med_structs[j].myBool) { } //76,500
                    //if (med_class[j].myBool) { } //58,000

                    //if (big_structs[j].myBool) { } //176,000 OOF
                    //if (big_class[j].myBool) { } //60,200 HMM
                }
            }
        }

        protected override void Draw(GameTime gameTime)
        {
            stopWatch.Stop();
            timespan = stopWatch.Elapsed;
            frameCount++;
            if (frameCount > 10) //discard the first 10 frames
            {
                totalTicks += timespan.Ticks;
                averageTicks = totalTicks / (frameCount - 10);
            }

            //baseline avg 5 from 10,000 frames
            e.Append("ticks this frame: " + timespan.Ticks);
            e.Append("\navg ticks per frame: " + averageTicks);
            e.Append("\ntotal frames: " + frameCount);
            e.Append("\ntotal time: " + total.Elapsed.ToString(@"hh\:mm\:ss"));
            text = e.ToString();
            e.Clear();

            //draw
            GraphicsDevice.Clear(Color.CornflowerBlue);
            spriteBatch.Begin();
            spriteBatch.DrawString(
                BitmapFont,
                text,
                position,
                color,
                rotation,
                origin,
                scale,
                spriteEffect,
                zDepth);
            spriteBatch.End();
            base.Draw(gameTime);
        }
    }
}
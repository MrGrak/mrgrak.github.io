using System;
using System.Text;
using System.Diagnostics;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using System.Collections.Generic;
using System.Threading;

namespace BaseProject
{
    //timing the use of Interlocked object, in job based design from part 1

    //create a class for our 'jobs'
    public abstract class TimingJob
    {
        public virtual void DoWork() { } 
    }

    //extend class with unique DoWork() method
    public class Time_ListOfData : TimingJob
    {
        public override void DoWork()
        {
            Stopwatch total = new Stopwatch();
            total.Start(); //we need to time our work

            //create a list of 1000 booleans
            int i;
            List<Boolean> booleans = new List<bool>();
            for (i = 0; i < 1000; i++) { booleans.Add(true); }

            //play with this list of booleans (check and set value)
            for (i = 0; i < 1000; i++)
            { if (booleans[i]) { booleans[i] = false; } }

            total.Stop(); //stop timing work, we're done
            //write completed data to the avg global instance
            AveragedData.listOfData_TotalTicks += total.ElapsedTicks;

            
            //allow threads to add value in parallel
            //AveragedData.listOfData_Completes ++; 
            //115ticks/18frames

            //force threads to sequentially update value
            Interlocked.Increment(ref AveragedData.listOfData_Completes);
            //111ticks/18frames
        }
    }

    //make a class to store job data for drawing to the screen
    public static class AveragedData
    {
        public static long listOfData_TotalTicks;
        public static int listOfData_TotalFrames;
        public static int listOfData_Completes;
        public static short listOfData_Avg;
    }
    
    //now we can create a list of TimingJobs
    //and add Time_ListOfData to it.
    //then, we can create Threads each frame
    //they will call the Time_ListOfData.DoWOrk() method
    //but they will do so from the list of jobs
    //later we can add more jobs, and the threads wont care

        

    public class Game1 : Game
    {
        GraphicsDeviceManager graphics;
        SpriteBatch spriteBatch;

        public Stopwatch stopWatch = new Stopwatch();
        public Stopwatch total = new Stopwatch();
        public TimeSpan timespan;
        public long averageTicks;
        public long totalTicks;
        public long frameCount;

        Vector2 position = new Vector2(4, 1);
        float rotation = 0.0f;
        Vector2 origin = new Vector2(0, 0);
        float scale = 1.0f;
        SpriteEffects spriteEffect = SpriteEffects.None;
        float zDepth = 0.1f;
        SpriteFont BitmapFont;
        Color color = Color.White;

        //used to quickly build a string to display data to screen each frame
        StringBuilder e = new StringBuilder();
        String text;
        int i;

        //create a list of timing jobs that we can add jobs to
        List<TimingJob> activeJobs = new List<TimingJob>();

        short threadsPerJob = 5000; //threads per job per frame
        int totalCompletes = 50000; //tests require this many completes to be done
        //testing results:
        //# of threads / # of completes = avg # of ticks over # of frames @ #% cpu use
        //10threads/10000completes = avg 64 ticks over 1003 frames @32%cpu - long wait
        //100threads/10000completes = avg 64 ticks over 101 frames @32%cpu
        //1000threads/10000completes = avg 64 ticks over 11 frames @38%cpu
        //10000threads/10000completes = avg 476 ticks over 8 frames @38%cpu - too many threads
        //5000threads/10000completes = avg 109 ticks over 3 frames - @42%cpu - better
        //number of completes are increasing now
        //10000thr/30000comps = avg 252 ticks over 13 frames @58%cpu - better
        //10000thr/50000comps = avg 271 ticks over 22 frames @97%cpu - very good
        //5000thr/50000comps = avg 80 ticks over 18 frames @50%cpu - <<< the best
        //1000thr/50000comps = avg 61 ticks over 61 frames @50%cpu - not good
        //looks like the 'sweet spot' for this job is a power of 10 less threads than totalComps




        public Game1()
        {
            graphics = new GraphicsDeviceManager(this);
            Content.RootDirectory = "Content";
            this.IsMouseVisible = true;
            graphics.PreferredBackBufferWidth = 640;
            graphics.PreferredBackBufferHeight = 360;
        }

        protected override void Initialize()
        {
            base.Initialize();
        }

        protected override void LoadContent()
        {
            spriteBatch = new SpriteBatch(GraphicsDevice);
            BitmapFont = Content.Load<SpriteFont>("Font_Pixel");
            total.Reset(); total.Start();
            averageTicks = 0;
            totalTicks = 0;
            frameCount = 0;

            //reset the global data instance
            AveragedData.listOfData_Avg = 0;
            AveragedData.listOfData_Completes = 0;
            AveragedData.listOfData_TotalTicks = 0;

            //add the unique timing job to the job list
            activeJobs.Add(new Time_ListOfData());
        }

        protected override void UnloadContent()
        {
        }

        protected override void Update(GameTime gameTime)
        {
            stopWatch.Reset();
            stopWatch.Start();
            base.Update(gameTime);
            //baseline (no forloop) = 5 ticks
            if (frameCount > 10) //ignore the first 10 frames
            {
                //lets implement some controls over our job system
                //we only want our active jobs to run 10k times, for example
                //then we want them to stop, so we know when tests have completed
                //we can do this by checking the global instance
                //but note we WILL read this value as it's being written to
                //thi means we never stop at totalCompletes, we're always over a bit
                //but we can use that as an additional 'state' to calculate the average
                //then trim off the extra test values, making everything look proper

                //check the global data instance to see if a job should process
                if (AveragedData.listOfData_Completes < totalCompletes)
                {
                    //throw the thread count at this job each frame
                    for (i = 0; i < threadsPerJob; i++)
                    { ThreadPool.QueueUserWorkItem(a => activeJobs[0].DoWork()); }
                    //we access the list by index, calling the method directly (not scaleable)
                    //we also should not be conceptually addressing the job this way, but it works
                    AveragedData.listOfData_TotalFrames++; //count this frame towards the job
                }
                else if (AveragedData.listOfData_Completes > totalCompletes)
                {
                    //we have completed the tests and need to set the average
                    AveragedData.listOfData_Avg = 0; //reset
                    AveragedData.listOfData_Avg = (short)
                        (AveragedData.listOfData_TotalTicks / AveragedData.listOfData_Completes);

                    //then cleanup the test display data
                    AveragedData.listOfData_Completes = totalCompletes;
                    //note this removes the job from execution and averaging branches above
                }
                //else this job has been completed..do nothing
            }
        }



        //update draw to show the avg data
        protected override void Draw(GameTime gameTime)
        {
            stopWatch.Stop();
            timespan = stopWatch.Elapsed;
            frameCount++;
            if (frameCount > 10) //discard the first 10 frames
            {
                totalTicks += timespan.Ticks;
                averageTicks = totalTicks / (frameCount - 10);
            }

            //baseline avg 5 from 10,000 frames
            e.Append("ticks this frame: " + timespan.Ticks);
            e.Append("\navg ticks per frame: " + averageTicks);
            e.Append("\ntotal frames: " + frameCount);
            e.Append("\ntotal time: " + total.Elapsed.ToString(@"hh\:mm\:ss"));

            //append thread values
            e.Append("\n\nthreads per job per frame: " + threadsPerJob);

            //append job values
            e.Append("\njob - bool list" + 
                " avg:" + AveragedData.listOfData_Avg + 
                " comp:" + AveragedData.listOfData_Completes +
                " total frames:" + AveragedData.listOfData_TotalFrames);

            //dump string builder to text string
            text = e.ToString();
            e.Clear();

            //draw
            GraphicsDevice.Clear(Color.CornflowerBlue);
            spriteBatch.Begin();
            spriteBatch.DrawString(
                BitmapFont,
                text,
                position,
                color,
                rotation,
                origin,
                scale,
                spriteEffect,
                zDepth);
            spriteBatch.End();
            base.Draw(gameTime);
        }
    }
}
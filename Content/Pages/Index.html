<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta charset="UTF-8">
	<title>MonoGame Getting Started Guide</title>
	<link rel="stylesheet" type="text/css" href="../style.css">
</head>
<body>
<article>


<h1>Introduction</h1>


<p>
What is mutability? What is immutability?<br>
<br>
If something is mutable, it can change overtime.<br>
If something is immutable, it cannot change overtime.<br>
<br>
<br>
<h3>A Simple Example</h3>
In C#, mutability means we create a variable and modify it later.<br>
Immutability means we create a new instance of our variable each time we want to modify it.<br>
<br>
<textarea rows="33" readonly>
namespace ConsoleApplication1
{
    struct Point2_im
    {   //immutable data
        public int X, Y;
        public Point2_im(int x, int y)
        {
            X = x; Y = y;
        }
    }
    class Point2_m
    {   //mutable data
        public int X, Y;
        public Point2_m(int x, int y)
        {
            X = x; Y = y;
        }
    }
    
    class Program
    {
        public static Point2_im immutablePoint = new Point2_im(16, 16);
        public static Point2_m mutablePoint = new Point2_m(16, 16);
        static void Main(string[] args)
        {
            immutablePoint = new Point2_im(32, 32); //values change via creation
            mutablePoint.X = 32; mutablePoint.Y = 32; //values change via assignment
        }
    }
}
</textarea>

<br>
<br>
<br>
<br>






<h3>The Cost of Immutability</h3>
When we assign new values to immutable data, we incur an allocation cost.<br>
We do not incur this allocation cost when using mutable data, as only memory addresses are modified.<br>
<br>
<textarea rows="52" readonly>
using System;
namespace ConsoleApplication1
{
    struct Point2_im
    {   //immutable data
        public int X, Y;
        public Point2_im(int x, int y) { X = x; Y = y; }
    }
    class Point2_m
    {   //mutable data
        public int X, Y;
        public Point2_m(int x, int y) {  X = x; Y = y; }
    }
    class Program
    {
        public static Point2_im immutablePoint = new Point2_im(16, 16);
        public static Point2_m mutablePoint = new Point2_m(16, 16);
        public static System.Diagnostics.Stopwatch timer = new System.Diagnostics.Stopwatch();
        static void Main(string[] args)
        {
            int g;
            int totalTests = 10000000;
            //test immutable cost
            timer.Restart();
            for (g = 0; g &lt totalTests; g++)
            { immutablePoint = new Point2_im(32, 32); }
            timer.Stop();
            Console.WriteLine("immutable test took " + timer.ElapsedTicks + " ticks.");
            //test mutable cost
            timer.Restart();
            for (g = 0; g &lt totalTests; g++)
            { mutablePoint.X = 32; mutablePoint.Y = 32; }
            timer.Stop();
            Console.WriteLine("mutable test took " + timer.ElapsedTicks + " ticks.");
            Console.Read();
        }
    }
}
//console results:
//immutable test took 317,227 ticks.
//mutable test took 63,717 ticks.
//in this test, immutable test took 4.978 times longer to complete than mutable test.

</textarea>

<br>
<br>
<br>
<br>

<h3>Why Use Immutability?</h3>
<ul>
  <li>immutable objects are simpler to construct, test, and use (subjective)</li>
  <li>truly immutable objects are always thread-safe</li>
  <li>they help to avoid temporal coupling (subjective)</li>
  <li>their usage is side-effect free (no defensive copies)</li>
  <li>identity mutability problem is avoided</li>
  <li>they always have failure atomicity</li>
</ul> 

<br>
<br>

<h3>Why Use Mutability?</h3>
<ul>
  <li>it's faster</li>
</ul> 

<br>
<br>


<h3>Comparing Mutability and Immutability</h3>

A good summary of mutable vs immutable data can be read <a target="_blank" href="https://softwareengineering.stackexchange.com/questions/151733/if-immutable-objects-are-good-why-do-people-keep-creating-mutable-objects">here</a>.<br>
<br>
Péter Török says:<br>
<br>
Both mutable and immutable objects have their own uses, pros and cons.<br>
<br>
Immutable objects do indeed make life simpler in many cases. They are especially applicable for value types, where objects don't have an identity so they can be easily replaced. And they can make concurrent programming way safer and cleaner (most of the notoriously hard to find concurrency bugs are ultimately caused by mutable state shared between threads). However, for large and/or complex objects, creating a new copy of the object for every single change can be very costly and/or tedious. And for objects with a distinct identity, changing an existing objects is much more simple and intuitive than creating a new, modified copy of it.<br>
<br>
Think about a game character. <b>In games, speed is top priority</b>, so representing your game characters with mutable objects will most likely make your game run significantly faster than an alternative implementation where a new copy of the game character is spawned for every little change.<br>
<br>
Moreover, our perception of the real world is inevitably based on mutable objects. When you fill up your car with fuel at the gas station, you perceive it as the same object all along (i.e. its identity is maintained while its state is changing) - not as if the old car with an empty tank got replaced with consecutive new car instances having their tank gradually more and more full. So whenever we are modeling some real-world domain in a program, it is usually more straightforward and easier to implement the domain model using mutable objects to represent real-world entities.<br>
<br>
Apart from all these legitimate reasons, alas, the most probable cause why people keep creating mutable objects is inertia of mind, a.k.a. resistance to change. Note that most developers of today have been trained well before immutability (and the containing paradigm, functional programming) became "trendy" in their sphere of influence, and don't keep their knowledge up to date about new tools and methods of our trade - in fact, many of us humans positively resist new ideas and processes. "I have been programming like this for nn years and I don't care about the latest stupid fads!"<br>
<br>
<br>

<h3>Summary</h3>

<textarea rows="6" readonly>
//immutable design is slower than mutable design.
//mutable design should be used when speed is important to program operation.
//immutable design should be used when speed is not important to program operation.
//immutable design may also make some problems easier to understand and solve.
</textarea>


</p>

<!--
<br><br><br>
<br><br><br>
<br><br><br>
<br><br><br>
<br><br><br>
<br><br><br>
<br><br><br>
<br><br><br>
<br><br><br>
<br><br><br>
<br><br><br>
<br><br><br>
<br><br><br>
<br><br><br>
<br><br><br>
<br><br><br>
<br><br><br>
<br><br><br>

<h3>HTML References</h3>


<br>
<p>
An Internal Link: <a href="Context.html" target="display">Link Name</a> - Neato!.<br>
An External Link: <a target="_blank" href="https://github.com/mrgrak">GitHub/Mrgrak</a> - How Cool!.<br>
</p>
<br>

<br><br>
<b>Bullet Lists</b><br>
<ul>
  <li>bullet one</li>
  <li>bullet two</li>
  <li>bullet three</li>
  <li>bullet four</li>
</ul> 
<br>


<br>
<p>video clip via iframe with ratio and min size</p>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/i8h5u5BgoJY" frameborder="0" allowfullscreen></iframe>
<br>
</p>



-->



<br><br><br>
<br><br><br>
<br><br><br>
</article>
</body>
</html>